(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0c02d1"],{4153:function(e,t,r){"use strict";r.r(t);var n=r("7a23");function c(e,t,r,c,o,s){return Object(n["openBlock"])(),Object(n["createBlock"])("ol",null,[(Object(n["openBlock"])(!0),Object(n["createBlock"])(n["Fragment"],null,Object(n["renderList"])(c.list,(function(e){return Object(n["openBlock"])(),Object(n["createBlock"])("li",{key:e.msg},[Object(n["createVNode"])("h3",null,Object(n["toDisplayString"])(e.msg),1)])})),128))])}var o={setup:function(){return{list:[{msg:"vue3.x 提供了可以在 setup 中通过在生命周期钩子前面加上 on 来访问组件的生命周期钩子"},{msg:"因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写。"},{msg:"vue3.x 废除了 2.x options API 生命周期中的 beforeDestroy destroyed 使用 unmounted 替代"},{msg:"renderTracked/onRenderTracked 和 renderTriggered/onRenderTriggered 貌似是可以监听数据变动的，用于调试仅在开发期间生效，而且官方也没给示例，慎用！！！"}]}}};o.render=c;t["default"]=o}}]);
//# sourceMappingURL=chunk-2d0c02d1.b01c40c6.js.map