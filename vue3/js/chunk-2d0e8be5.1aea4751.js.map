{"version":3,"sources":["webpack:///./src/views/TemplateRef.vue","webpack:///./src/views/TemplateRef.vue?ce8f"],"names":["ref","list","item","key","msg","setup","useRefEle","console","log","value","render"],"mappings":"4IAEQA,IAAI,a,wDADV,yBAGK,WAFH,yBAAkC,KAAlC,EAAoB,YAAS,M,2BAC7B,yBAA6D,2CAA1C,EAAAC,MAAI,SAAZC,G,gCAAX,yBAA6D,MAAnCC,IAAKD,EAAKE,IAAK,UAAQF,EAAKE,K,iCAO3C,OACbC,MADa,WAEX,IAAMC,EAAY,iBAAI,MAItB,OAHA,wBAAU,WACRC,QAAQC,IAAIF,EAAUG,UAEjB,CACLH,YACAL,KAAM,CACJ,CAAEG,IAAK,qHACP,CAAEA,IAAK,iFACP,CAAEA,IAAK,4CACP,CAAEA,IAAK,4DACP,CAAEA,IAAK,oEACP,CAAEA,IAAK,oECrBf,EAAOM,OAASA,EAED","file":"js/chunk-2d0e8be5.1aea4751.js","sourcesContent":["<template>\r\n  <ol>\r\n    <h3 ref=\"useRefEle\">useRefEle</h3>\r\n    <li v-for=\"item in list\" :key=\"item.msg\" v-html=\"item.msg\" />\r\n  </ol>\r\n</template>\r\n\r\n<script>\r\nimport { onMounted, ref } from 'vue'\r\n\r\nexport default {\r\n  setup () {\r\n    const useRefEle = ref(null)\r\n    onMounted(() => {\r\n      console.log(useRefEle.value)\r\n    })\r\n    return {\r\n      useRefEle,\r\n      list: [\r\n        { msg: 'vue2.x 在摸板提供了 ref 属性用于获取 dom 或子组件实例，vue3.x 提供了 ref 函数用于定义响应式变量，在 setup 中 return 和模板中 ref 值同名的 ref，vue3.x 会对它们进行绑定' },\r\n        { msg: '摸板中的 ref 绑定都是原生 html 标签或者自定义组件，因此在 setup 中通过 ref 操作模板中的 ref 需要在 onMounted 中执行' },\r\n        { msg: 'setup 中的 ref 即使绑定了模板中的 ref，操作也需要通过 value' },\r\n        { msg: '模板中的 ref 值通常是字符串，就是 ref 名称。但是 ref 也可以h是一个函数，函数的参数是当前 ref' },\r\n        { msg: '绑定后 ref 也可以 watch。需要注意的是 watch/watchEffect 是在 DOM/组件 被挂载或更新之前运行的' },\r\n        { msg: '因此当侦听器运行副作用时，模板引用还没有被更新，因此，使用模板引用的侦听器应该用 flush: \"post\" 选项来定义' }\r\n      ]\r\n    }\r\n  }\r\n}\r\n</script>\r\n","import { render } from \"./TemplateRef.vue?vue&type=template&id=323d138e\"\nimport script from \"./TemplateRef.vue?vue&type=script&lang=js\"\nexport * from \"./TemplateRef.vue?vue&type=script&lang=js\"\nscript.render = render\n\nexport default script"],"sourceRoot":""}