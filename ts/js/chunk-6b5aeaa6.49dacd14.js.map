{"version":3,"sources":["webpack:///./src/views/Class.vue","webpack:///./src/views/Class.vue?0329","webpack:///./src/views/Class.vue?07e9","webpack:///./node_modules/@babel/runtime/helpers/esm/classCallCheck.js"],"names":["list","item","key","setup","Person","name","age","live","this","console","log","render","_classCallCheck","instance","Constructor","TypeError"],"mappings":"uLACE,eAEK,Y,mBADH,eAAqD,2BAAlC,EAAAA,MAAI,SAAZC,G,wBAAX,eAAqD,MAA3BC,IAAKD,EAAM,UAAQA,G,iDCDlC,G,UAAA,CACbE,MADa,WACR,IACGC,EAIJ,WAAaC,EAAcC,GAAW,uBAH/B,KAAAC,MAAO,EAIZC,KAAKH,KAAOA,EACZG,KAAKF,IAAMA,GAKf,OADAG,QAAQC,IAAI,IAAIN,EAAO,MAAO,KACvB,CACLJ,KAAM,CACJ,8FACA,kCACA,mCACA,gEACA,6CACA,6EACA,6FCnBR,EAAOW,OAASA,EAED,gB,kCCLA,SAASC,EAAgBC,EAAUC,GAChD,KAAMD,aAAoBC,GACxB,MAAM,IAAIC,UAAU,qCAFxB","file":"js/chunk-6b5aeaa6.49dacd14.js","sourcesContent":["<template>\n  <ol>\n    <li v-for=\"item in list\" :key=\"item\" v-html=\"item\" />\n  </ol>\n</template>\n\n<script lang=\"ts\">\nexport default {\n  setup (): { list: string[] } {\n    class Person {\n      public live = true\n      public name: string\n      public age: number\n      constructor (name: string, age: number) {\n        this.name = name\n        this.age = age\n      }\n    }\n\n    console.log(new Person('ycn', 18))\n    return {\n      list: [\n        'TypeScript 比 JavaScript 更好更早的支持 class 语法，因此你可以放心使用 class 语法，并且 Typescript 对 class 语法做了进一步增强',\n        '在TypeScript里，类中的所有成员都默认为 public',\n        '当成员被标记成 private时，它就不能在声明它的类的外部访问',\n        'protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问',\n        'readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化',\n        'TypeScript支持通过getters/setters来截取对对象成员的访问，只带有 get不带有 set的存取器自动被推断为 readonly',\n        '抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法'\n      ]\n    }\n  }\n}\n</script>\n","\nexport default {\n  setup (): { list: string[] } {\n    class Person {\n      public live = true\n      public name: string\n      public age: number\n      constructor (name: string, age: number) {\n        this.name = name\n        this.age = age\n      }\n    }\n\n    console.log(new Person('ycn', 18))\n    return {\n      list: [\n        'TypeScript 比 JavaScript 更好更早的支持 class 语法，因此你可以放心使用 class 语法，并且 Typescript 对 class 语法做了进一步增强',\n        '在TypeScript里，类中的所有成员都默认为 public',\n        '当成员被标记成 private时，它就不能在声明它的类的外部访问',\n        'protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问',\n        'readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化',\n        'TypeScript支持通过getters/setters来截取对对象成员的访问，只带有 get不带有 set的存取器自动被推断为 readonly',\n        '抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法'\n      ]\n    }\n  }\n}\n","import { render } from \"./Class.vue?vue&type=template&id=7a32882a\"\nimport script from \"./Class.vue?vue&type=script&lang=ts\"\nexport * from \"./Class.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}"],"sourceRoot":""}