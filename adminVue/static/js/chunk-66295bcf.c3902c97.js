(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-66295bcf"],{"0625":function(e,n,t){"use strict";var i=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("transition",{attrs:{name:e.transitionName}},[t("div",{directives:[{name:"show",rawName:"v-show",value:e.visible,expression:"visible"}],staticClass:"back-to-ceiling",style:e.customStyle,on:{click:e.backToTop}},[t("svg",{staticClass:"Icon Icon--backToTopArrow",staticStyle:{height:"16px",width:"16px"},attrs:{width:"16",height:"16",viewBox:"0 0 17 17",xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true"}},[t("path",{attrs:{d:"M12.036 15.59a1 1 0 0 1-.997.995H5.032a.996.996 0 0 1-.997-.996V8.584H1.03c-1.1 0-1.36-.633-.578-1.416L7.33.29a1.003 1.003 0 0 1 1.412 0l6.878 6.88c.782.78.523 1.415-.58 1.415h-3.004v7.004z"}})])])])},o=[],s=(t("a9e3"),{name:"BackToTop",props:{visibilityHeight:{type:Number,default:400},backPosition:{type:Number,default:0},customStyle:{type:Object,default:function(){return{right:"50px",bottom:"50px",width:"40px",height:"40px","border-radius":"4px","line-height":"45px",background:"#e7eaf1"}}},transitionName:{type:String,default:"fade"}},data:function(){return{visible:!1,interval:null,isMoving:!1}},mounted:function(){window.addEventListener("scroll",this.handleScroll)},beforeDestroy:function(){window.removeEventListener("scroll",this.handleScroll),this.interval&&clearInterval(this.interval)},methods:{handleScroll:function(){this.visible=window.pageYOffset>this.visibilityHeight},backToTop:function(){var e=this;if(!this.isMoving){var n=window.pageYOffset,t=0;this.isMoving=!0,this.interval=setInterval((function(){var i=Math.floor(e.easeInOutQuad(10*t,n,-n,500));i<=e.backPosition?(window.scrollTo(0,e.backPosition),clearInterval(e.interval),e.isMoving=!1):window.scrollTo(0,i),t++}),8)}},easeInOutQuad:function(e,n,t,i){return(e/=i/2)<1?t/2*e*e+n:-t/2*(--e*(e-2)-1)+n}}}),a=s,r=(t("b75e"),t("2877")),p=Object(r["a"])(a,i,o,!1,null,"9ad42138",null);n["a"]=p.exports},1125:function(e,n,t){"use strict";t.r(n);var i=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"main-article"},[t("aside",{directives:[{name:"show",rawName:"v-show",value:!e.printing,expression:"!printing"}],staticStyle:{"margin-top":"15px"}},[t("div",{staticStyle:{display:"flex","justify-content":"space-between"}},[t("strong",[e._v("文档下载页面（选择目标打印机为 [ 另存为 PDF ] 后点击保存即可）")]),t("el-button",{attrs:{type:"primary"},on:{click:e.download}},[e._v("下载")])],1),e._l(e.h2,(function(n){return t("a",{key:n.id,staticStyle:{display:"block"},on:{click:function(t){return e.window.scrollTo(0,n.offsetTop-n.offsetHeight)}}},[e._v(e._s(n.id))])}))],2),t("div",{ref:"content",staticClass:"node-article-content",domProps:{innerHTML:e._s(e.README)}}),t("back-to-top")],1)},o=[],s=(t("a630"),t("3ca3"),t("82a9")),a=t.n(s),r=t("0625"),p={components:{BackToTop:r["a"]},data:function(){return{README:a.a,h2:[],title:"zfcc-admin-ui 说明文档"}},computed:{printing:function(){return this.$store.state.app.printing}},mounted:function(){var e=this;document.title=this.title;var n=function(){e.$store.dispatch("app/togglePrinting",!1)};window.addEventListener("afterprint",n),this.$once("hook:beforeDestroy",(function(){window.removeEventListener("afterprint",n)})),this.$alert("选择目标打印机为 [ 另存为 PDF ] 后点击保存即可",{showClose:!1,closeOnClickModal:!1,closeOnPressEscape:!1}).then((function(){setTimeout((function(){return e.download()}),520)})),this.h2=Array.from(this.$refs.content.getElementsByTagName("h2"))},methods:{download:function(){this.$store.dispatch("app/togglePrinting",!0),this.$nextTick((function(){return window.print()}))}}},c=p,l=t("2877"),u=Object(l["a"])(c,i,o,!1,null,null,null);n["default"]=u.exports},6878:function(e,n,t){},"82a9":function(e,n){var t='<h1 id="zfcc-admin-ui-项目文档">zfcc-admin-ui 项目文档</h1> <hr> <p>本项目为使用 Vue 全家桶及 ElementUI 开发的 SPA。同时参考了多个成熟的企业级中后台产品解决方案，包括但不仅限于 vue-element-admin 、layUI 等。在结合这些方案的同时，对大部分主要功能进行了扩充和重构，不仅使得功能实现更为优雅，也更易维护和拓展。同时增加汇总了可配置项，并对演示部分和业务部分做了抽离，使得可以在此基础上快速优雅的搭建企业级中后台产品原型。并且本项目使用了最新的前端技术栈，内置了动态路由，权限验证等，同时保证了实用性和技术性。</p> <h3 id="前序准备">前序准备</h3> <p>需要在本地安装 node 和 git。本项目技术栈基于 ES2015+、vue、vuex、vue-router、vue-cli、axios 和 element-ui，所有的请求数据都使用 Mock.js 进行模拟。</p> <h3 id="安装">安装</h3> <pre><code class="language-bash"># 克隆项目\ngit clone https://git.dev.every-xx.com/zfcc/zfcc-admin-ui\n\n# 进入项目目录\ncd zfcc-admin-ui\n\n# 安装依赖\nnpm install\n\n# 建议不要用 cnpm 安装 会有各种诡异的bug 可以通过如下操作解决 npm 下载速度慢的问题\nnpm install --registry=https://registry.npm.taobao.org\n\n# 本地开发 启动项目\nnpm run dev</code></pre> <h3 id="项目目录">项目目录</h3> <p>本项目已经为你生成了一个完整的开发框架，提供了涵盖中后台开发的各类功能和坑位，下面是整个项目的目录结构。</p> <pre><code>- build // 项目预构建配置\n    - index.js // 项目预览/分析构建文件体积配置（相关命令见：package.json）\n    - clearSvg.js // 检查/清除 icon 文件夹下无用的 svg（相关命令见：package.json）\n- mock // 数据接口模拟\n    - apis // 接口\n      index.js // 接口整合\n      server.js // 接口挂载服务\n      utils.js // 接口处理工具方法\n- plop-templates // plop 快速新建模板\n    - component // 组件模板\n    - store // vuex module 模板\n    - view // 页面模板\n- public // 公共文件目录\n      index.html // 页面\n      favicon.ico // ico\n- src // 项目源码\n    - api // 接口\n    - assets // 静态资源\n    - components // 组件\n    - icons // 图标\n    - layout // 布局\n    - plugin // 全局 指令、过滤器、对象\n    - router // 路由\n    - store // vuex\n    - styles // 样式\n    - util // 工具\n    - vendor // 第三方工具库\n    - views // 所有业务页面\n    - views-constant // 所有的公共页面\n    - views-ui-template // 所有的UI模板页面\n      App.vue // 根组件\n      main.js // 项目入口文件\n      permission.js // 权限控制\n      setting.js // 初始设置\n  test // 测试工具文件目录\n  .editorconfig // vscode 配置\n  .env.development // 开发环境参数\n  .env.production // 生产环境参数\n  .env.staging // 预发布环境参数\n  .eslintignore // eslint 生效文件夹配置\n  .eslintrc.js // eslint 配置\n  .gitignore // git 配置\n  .travis.yml // 自动化 CI 配置\n  babel.config.js // babel 配置\n  jest.config.js // jest 配置\n  jsconfig.json // js 根目录配置\n  package.json // node 包信息\n  package-lock.json // node 包依赖信息\n  plopfile.js // plop 配置\n  postcss.config.js // postcss 配置\n  README.md // README.md\n  vue.config.js // vue-cli 配置</code></pre><h3 id="快速开始">快速开始</h3> <p>将 <strong>/src/settings.js</strong> 中 showUI 参数设置为 false 即可隐藏所有示例 UI 模板页面开始快速开发。或者你也可以在 <strong>/src/router</strong> 中移除响应路由。</p> <hr> <h2 id="1、布局">1、布局</h2> <p>页面整体布局是一个产品最外层的框架结构，往往会包含导航、侧边栏、面包屑以及内容等。想要了解一个后台项目，先要了解它的基础布局。</p> <p><img src="https://panjiachen.gitee.io/gitee-cdn/vue-element-admin-site/7066d74f-12c5-47d6-b6ad-f22b43fec917.png" alt=""></p> <p>对应的代码在 layout 文件夹下。而 zfcc-admin-ui 中大部分页面都是基于这个 layout 的，除了个别页面如：login , 404, 401 等页面没有使用该 layout。如果你想在一个项目中有多种不同的 layout 也是很方便的，只要在一级路由那里选择不同的 layout 组件就行。</p> <pre><code class="language-js">// 没有使用 layout\n{\n    path: &#39;/401&#39;,\n    component: () =&gt; import(&#39;errorPage/401&#39;)\n}\n// 使用了 layout\n{\n    path: &#39;/document&#39;,\n    component: Layout, // 你可以选择不同的layout组件\n    children: [\n        {\n            path: &#39;index&#39;,\n            name: &#39;Document&#39;,\n            component: () =&gt; import(&#39;document/index&#39;)\n        }\n    ]\n}</code></pre> <p>这里使用了 vue-router 路由嵌套, 所以一般情况下，你增加或者修改页面只会影响 app-main 这个主体区域。其它配置在 layout 中的内容如：侧边栏或者导航栏都是不会随着你主体页面变化而变化的。</p> <pre><code>/foo                                  /bar\n+------------------+                  +-----------------+\n| layout           |                  | layout          |\n| +--------------+ |                  | +-------------+ |\n| | foo.vue      | |  +------------&gt;  | | bar.vue     | |\n| |              | |                  | |             | |\n| +--------------+ |                  | +-------------+ |\n+------------------+                  +-----------------+</code></pre><p>当然你也可以一个项目里面使用多个不同的 layout，只要在你想作用的路由父级上引用它就可以了。</p> <h3 id="app-main">app-main</h3> <hr> <p><strong>对应代码: /src/layout/components/AppMain.vue</strong></p> <p>这里在 app-main 外部包了一层 keep-alive 主要是为了缓存 router-view 的，配合页面的 tabs-view 标签导航使用，如不需要可自行去除(详细见下方：快捷标签)。</p> <p>其中 transition 定义了页面之间切换动画，可以根据自己的需求，自行修改转场动画。默认提供了fade 和 fade-transform 两个转场动画，具体 css 实现见 /src/styles/transition.scss。如果需要调整可在 AppMain.vue 中调整 transition 的 name。</p> <h3 id="portal">portal</h3> <hr> <p><strong>对应代码: /src/layout/components/AppMain.vue</strong></p> <p>通常情况下，我们只需要将页面渲染至 layout 中 app-main 的 router-view 就好。这样渲染出来的页面都会默认带有 layout 布局。但是有些时候，我们想要页面可以控制 layout 的显示/隐藏。比如在项目文档页面，当我们调用 window.print() 希望将当前页面的文档部分打印时，就自然不希望把布局也打印上，因此就需要一种方式去控制 layout 的显示隐藏。但是实际上文档还存在于 layout 中，layout 隐藏，文档自然也会隐藏。因此其实我们要做的就是将 layout 隐藏的同时，将文档部分渲染到 layout 以外。即触发某种情况，将子组件渲染到父组件以外的地方。</p> <p>这里使用了 portal-vue 库来实现了类似 React 中的 portal 功能。同时使用 vuex 共享状态。具体使用不再赘述。需要注意的是，触发 portal 的子组件在渲染至父组件以外的地方时，会重新从头执行组件内的生命周期函数。原理是 portal-vue 从 Virtual DOM 层面改变了 dom 结构。同时 portal 功能将会在 Vue3.x 后提供官方支持。</p> <p>最后你也可以通过操作真实 dom 的方式将子组件移到父组件外部，但是强烈不推荐。</p> <h3 id="移动端">移动端</h3> <hr> <p>zfcc-admin-ui 对自己的定位是桌面端后台框架，而且对于管理后台这种重交互的项目来说是不能通过简单的适配来满足桌面端和移动端两端不同的交互，所以真要做移动版后台，建议重新做一套系统。</p> <p>所以本项目也不会适配移动端，只是用 media query 做了一点简单的响应式布局，有需求请自行修改。</p> <h2 id="2、路由和侧边栏">2、路由和侧边栏</h2> <p>路由和侧边栏是组织起一个后台应用的关键骨架。</p> <p>本项目侧边栏和路由是绑定在一起的，所以你只要在 /src/router/index.js 下面配置对应的路由，侧边栏就能动态的生成了。大大减轻了手动重复编辑侧边栏的工作量。当然这样就需要在配置路由的时候遵循一些约定的规则。</p> <h3 id="配置项">配置项</h3> <hr> <p>首先我们了解一下本项目配置路由时提供了哪些配置项。</p> <pre><code class="language-js">hidden: true // 当设置 true 的时候该路由不会在侧边栏出现 如401，login等页面，或者如一些编辑页面 /edit/1(默认 false)\nredirect: &#39;noRedirect&#39; //当设置 noRedirect 的时候该路由在面包屑导航中不可被点击\n\n// 当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式--如组件页面\n// 只有一个时，会将那个子路由当做根路由显示在侧边栏--如引导页面\n// 若你想不管路由下面的 children 声明的个数都显示你的根路由\n// 你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，一直显示根路由\nalwaysShow: true\n\nname: &#39;router-name&#39; // 设定路由的名字，一定要填写不然使用&lt;keep-alive&gt;时会出现各种问题\n\nmeta: {\n    title: &#39;title&#39; // 设置该路由在侧边栏和面包屑中展示的名字\n    icon: &#39;svg-name&#39; // 设置该路由的图标，支持 svg-class，也支持 el-icon-x element-ui 的 icon\n    noCache: true // 如果设置为true，则不会被 &lt;keep-alive&gt; 缓存(默认 false)\n    breadcrumb: false //  如果设置为false，则不会在breadcrumb面包屑中显示(默认 true)\n    affix: true // 若果设置为true，它则会固定在tags-view中(默认 false)\n    target: &#39;_blank&#39; // 路由是否在新的页面打开，打开后默认没有 layout\n    layout: false // 路由是否在新的页面后是否有 layout\n\n    // 当路由设置了该属性，则会高亮相对应的侧边栏。\n    // 这在某些场景非常有用，比如：一个文章的列表页路由为：/article/list\n    // 点击文章进入文章详情页，这时候路由为/article/1，但你想在侧边栏高亮文章列表的路由，就可以进行如下设置\n    activeMenu: &#39;/article/list&#39;\n}</code></pre> <p><strong>示例：</strong></p> <pre><code class="language-js">{\n    path: &#39;/permission&#39;,\n    component: Layout,\n    redirect: &#39;/permission/index&#39;, //重定向地址，在面包屑中点击会重定向去的地址\n    hidden: true, // 不在侧边栏线上\n    alwaysShow: true, //一直显示根路由\n    children: [{\n        path: &#39;index&#39;,\n        component: ()=&gt;import(&#39;permission/index&#39;),\n        name: &#39;permission&#39;,\n        meta: {\n            title: &#39;permission&#39;,\n            icon: &#39;lock&#39;, //图标\n            noCache: true // 不会被 &lt;keep-alive&gt; 缓存\n        }\n    }]\n}</code></pre> <h3 id="路由">路由</h3> <hr> <p>这里的路由分为两种，constantRoutes 和 asyncRoutes。</p> <p><strong>constantRoutes：</strong> 代表那些不需要动态判断权限的路由，如登录页、404、等通用页面。</p> <p><strong>asyncRoutes：</strong> 代表那些需求动态判断权限并通过 addRoutes 动态添加的页面。</p> <p>具体的会在 下一部分（权限验证）介绍。</p> <p>其它的配置和 vue-router 官方并没有区别，自行查看文档。</p> <p>如果这里有一个需要非常注意的地方就是 404 页面一定要最后加载，如果放在 constantRoutes 一同声明了 404 ，后面的所以页面都会被拦截到404。</p> <h3 id="侧边栏">侧边栏</h3> <hr> <p>本项目侧边栏主要基于 element-ui 的 el-menu 改造。</p> <p>前面也介绍了，侧边栏是通过读取路由并结合权限判断而动态生成的，而且还需要支持路由无限嵌套，所以这里还使用到了递归组件。</p> <p><strong>对应代码: /src/layout/components/Sidebar</strong></p> <p>这里同时也改造了 element-ui 默认侧边栏不少的样式，所有的 css 都可以在 <strong>/src/styles/sidebar.scss</strong> 中找到，你也可以根据自己的需求进行修改。</p> <p>这里需要注意一下，一般侧边栏有两种形式即：submenu 和 直接 el-menu-item。 一个是嵌套子菜单，另一个则是直接一个链接。如下图：</p> <p><img src="https://panjiachen.gitee.io/gitee-cdn/vue-element-admin-site/e94739d6-d701-45c8-8c6e-0f4bb10c3b46.png" alt=""></p> <p>在 Sidebar 中已经帮你做了判断，当你一个路由下面的 children 声明的路由大于&gt;1 个时，自动会变成嵌套的模式。如果子路由正好等于一个就会默认将子路由作为根路由显示在侧边栏中。若不想这样，可以通过设置在根路由中设置 alwaysShow: true 来取消这一特性。</p> <p>你可以在 <strong>/src/layout/components/Sidebar/index.vue</strong> 中设置 unique-opened 来控制侧边栏，是否只保持一个子菜单的展开。</p> <h3 id="多级目录嵌套路由">多级目录(嵌套路由)</h3> <hr> <p>如果你的路由是多级目录，有三级路由嵌套的情况下，不要忘记还要手动在二级目录的根文件下添加一个 <router-view>。</router-view></p> <pre><code class="language-html">&lt;template&gt;\n  &lt;router-view /&gt;\n&lt;/template&gt;</code></pre> <p>如：<strong>/src/views/components/editor</strong>。原则上有多少级路由嵌套就需要多少个。</p> <h3 id="点击侧边栏-刷新当前路由">点击侧边栏 刷新当前路由</h3> <hr> <p>在用 spa(单页面应用) 这种开发模式之前，用户每次点击侧边栏都会重新请求这个页面，用户渐渐养成了点击侧边栏当前路由来刷新 view 的习惯。但现在 spa 就不一样了，用户点击当前高亮的路由并不会刷新 view，因为 vue-router 会拦截你的路由，它判断你的 url 并没有任何变化，所以它不会触发任何钩子或者是 view 的变化。</p> <p>社区也对该问题展开了激烈讨论。尤大本来也说要增加一个方法来强刷 view，但后来他又改变了心意/(ㄒ o ㄒ)/~~。但需求就摆在这里，我们该怎么办呢？他说了不改变 current URL 就不会触发任何东西，那我可不可以强行触发你的 hook 呢？上有政策， 下有对策我们变着花来 hack。方法也很简单，通过一个中间页面作为过渡。判断当前点击的菜单路由和当前的路由是否一致，但一致的时候，会先跳转到一个专门 Redirect 的页面，它会将路由重定向到我想去的页面，这样就起到了刷新的效果了。</p> <pre><code class="language-js">refresh(name) { // 点击侧边栏刷新页面\n    if (this.$route.name === name) {\n        this.$router.replace({\n            path: &#39;/redirect&#39; + this.$route.fullPath\n        })\n    }\n}</code></pre> <h3 id="面包屑">面包屑</h3> <hr> <p>本项目中也封装了一个面包屑导航，它也是通过 watch $route 变化动态生成的。它和 menu 也一样，也可以通过之前那些配置项控制一些路由在面包屑中的展现。大家也可以结合自己的业务需求增改这些自定义属性。比如可以在路由中声明 breadcrumb:false ，让其不在 breadcrumb 面包屑显示。</p> <h3 id="侧边栏滚动问题">侧边栏滚动问题</h3> <hr> <p>之前版本的滚动都是用 css 来做处理的</p> <pre><code class="language-css">overflow-y: scroll;\n\n::-webkit-scrollbar {\n  display: none;\n}</code></pre> <p>首先这样写会有兼容性问题，在火狐或者其它低版本浏览器中都会比较不美观。其次在侧边栏收起的情况下，受限于 element-ui 的 menu 组件的实现方式，不能使用该方式来处理。</p> <p>所以现版本中使用了 el-scrollbar 来处理侧边栏滚动问题。</p> <h3 id="侧边栏-外链">侧边栏 外链</h3> <hr> <p>你也可以在侧边栏中配置一个外链，只要你在 path 中填写了合法的 url 路径，当你点击侧边栏的时候就会帮你新开这个页面。</p> <h3 id="侧边栏默认展开">侧边栏默认展开</h3> <hr> <p>可以通过 default-openeds 来进行设置。<strong>/src/layout/components/Sidebar/index.vue</strong>。需要注意的是 :default-openeds=&quot;[&#39;/example&#39;,&#39;/nested&#39;]&quot; 里面填写的是 submenu 的 route-path。</p> ';e.exports=t},b75e:function(e,n,t){"use strict";var i=t("6878"),o=t.n(i);o.a}}]);