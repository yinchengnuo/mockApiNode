{"version":3,"sources":["webpack:///./node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack:///./src/views/Interface.vue","webpack:///./src/views/Interface.vue?850a","webpack:///./src/views/Interface.vue?f6bb"],"names":["_classCallCheck","instance","Constructor","TypeError","list","item","key","setup","get","person","console","log","name","set","setTest","test","sex","height","a","Mock","x","y","currentTime","Date","render"],"mappings":"gHAAe,SAASA,EAAgBC,EAAUC,GAChD,KAAMD,aAAoBC,GACxB,MAAM,IAAIC,UAAU,qCAFxB,mC,yGCCE,eAEK,Y,mBADH,eAAqD,2BAAlC,EAAAC,MAAI,SAAZC,G,wBAAX,eAAqD,MAA3BC,IAAKD,EAAM,UAAQA,G,iDCDlC,G,UAAA,CACbE,MADa,WAaX,SAASC,EAAKC,GACZC,QAAQC,IAAIF,EAAOG,MAErB,SAASC,EAAKJ,GAA6B,IAAZG,EAAY,uDAAL,MACpCH,EAAOG,KAAOA,EAKhB,SAASE,EAASC,GAChBL,QAAQC,IAAII,GAJdP,EAAI,CAAEI,KAAM,MAAOI,IAAK,EAAGC,OAAQ,MACnCJ,EAAI,CAAED,KAAM,KAKZE,EAAQ,CAAEI,EAAG,MAxBV,IA8BGC,EAEJ,WAAoBC,EAAkBC,GAAS,uBAA3B,KAAAD,IAAkB,KAAAC,IADtC,KAAAC,YAAc,IAAIC,KAEhBb,QAAQC,IAAI,MAMhB,OAFAD,QAAQC,IAAI,IAAIQ,EAAK,EAAG,IAEjB,CACLf,KAAM,CACJ,4CACA,uEACA,8DACA,8DACA,oDACA,mFACA,4DACA,kCACA,mEChDR,EAAOoB,OAASA,EAED","file":"js/chunk-0089f2e4.3c3867fa.js","sourcesContent":["export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","<template>\n  <ol>\n    <li v-for=\"item in list\" :key=\"item\" v-html=\"item\" />\n  </ol>\n</template>\n\n<script lang=\"ts\">\nexport default {\n  setup (): { list: string[] } {\n    interface Person {\n      name: string,\n      age?: number,\n      [_: string]: unknown\n    }\n\n    interface Test {\n      name?: string,\n      age?: number\n    }\n\n    function get (person : Person) {\n      console.log(person.name)\n    }\n    function set (person : Person, name = 'ycn') {\n      person.name = name\n    }\n    get({ name: 'ycn', sex: 0, height: 200 })\n    set({ name: '' })\n\n    function setTest (test: Test) {\n      console.log(test)\n    }\n    setTest({ a: 123 } as Test)\n\n    interface mockInterface {\n      currentTime: Date\n    }\n\n    class Mock implements mockInterface {\n      currentTime = new Date()\n      constructor (public x: number, public y: number) {\n        console.log(123)\n      }\n    }\n\n    console.log(new Mock(1, 2))\n\n    return {\n      list: [\n        '在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型',\n        'TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape」进行描述',\n        '接口一般首字母大写，定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的，变量的形状必须和接口的形状保持一致',\n        '有时我们希望不要完全匹配一个形状，那么可以用可选属性，可选属性的含义是该属性可以不存在，这时仍然不允许添加未定义的属性',\n        '一些对象属性只能在对象刚刚创建的时候修改其值，你可以在属性名前用 readonly 来指定只读属性',\n        'TypeScript 具有 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改',\n        '接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型',\n        'TypeScript也能够用它来明确的强制一个类去符合某种契约',\n        '和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里'\n      ]\n    }\n  }\n}\n</script>\n","\nexport default {\n  setup (): { list: string[] } {\n    interface Person {\n      name: string,\n      age?: number,\n      [_: string]: unknown\n    }\n\n    interface Test {\n      name?: string,\n      age?: number\n    }\n\n    function get (person : Person) {\n      console.log(person.name)\n    }\n    function set (person : Person, name = 'ycn') {\n      person.name = name\n    }\n    get({ name: 'ycn', sex: 0, height: 200 })\n    set({ name: '' })\n\n    function setTest (test: Test) {\n      console.log(test)\n    }\n    setTest({ a: 123 } as Test)\n\n    interface mockInterface {\n      currentTime: Date\n    }\n\n    class Mock implements mockInterface {\n      currentTime = new Date()\n      constructor (public x: number, public y: number) {\n        console.log(123)\n      }\n    }\n\n    console.log(new Mock(1, 2))\n\n    return {\n      list: [\n        '在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型',\n        'TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape」进行描述',\n        '接口一般首字母大写，定义的变量比接口少了一些属性是不允许的，多一些属性也是不允许的，变量的形状必须和接口的形状保持一致',\n        '有时我们希望不要完全匹配一个形状，那么可以用可选属性，可选属性的含义是该属性可以不存在，这时仍然不允许添加未定义的属性',\n        '一些对象属性只能在对象刚刚创建的时候修改其值，你可以在属性名前用 readonly 来指定只读属性',\n        'TypeScript 具有 ReadonlyArray<T> 类型，它与 Array<T> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改',\n        '接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型',\n        'TypeScript也能够用它来明确的强制一个类去符合某种契约',\n        '和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里'\n      ]\n    }\n  }\n}\n","import { render } from \"./Interface.vue?vue&type=template&id=fa706216\"\nimport script from \"./Interface.vue?vue&type=script&lang=ts\"\nexport * from \"./Interface.vue?vue&type=script&lang=ts\"\nscript.render = render\n\nexport default script"],"sourceRoot":""}