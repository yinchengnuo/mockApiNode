(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-6b5aeaa6"],{be7e:function(t,e,n){"use strict";n.r(e);var c=n("7a23");function r(t,e,n,r,a,i){return Object(c["o"])(),Object(c["d"])("ol",null,[(Object(c["o"])(!0),Object(c["d"])(c["a"],null,Object(c["s"])(r.list,(function(t){return Object(c["o"])(),Object(c["d"])("li",{key:t,innerHTML:t},null,8,["innerHTML"])})),128))])}var a=n("d4ec"),i=(n("b0c0"),{setup:function(){var t=function t(e,n){Object(a["a"])(this,t),this.live=!0,this.name=e,this.age=n};return console.log(new t("ycn",18)),{list:["TypeScript 比 JavaScript 更好更早的支持 class 语法，因此你可以放心使用 class 语法，并且 Typescript 对 class 语法做了进一步增强","在TypeScript里，类中的所有成员都默认为 public","当成员被标记成 private时，它就不能在声明它的类的外部访问","protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问","readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化","TypeScript支持通过getters/setters来截取对对象成员的访问，只带有 get不带有 set的存取器自动被推断为 readonly","抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法"]}}});i.render=r;e["default"]=i},d4ec:function(t,e,n){"use strict";function c(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}n.d(e,"a",(function(){return c}))}}]);
//# sourceMappingURL=chunk-6b5aeaa6.49dacd14.js.map